## 基于Array实现的List:

1.需要提前分配一块大内存MAX_SIZE。

2.需要有一个变量count来追踪当前List大小。例：每插入一个值就count++。

3.需要大量移动元素。比如列表原先是{1, 2, 3, 4, 5}，现在想在位置2处插入100变为{1, 2, 100, 3, 4, 5}。那么在实际操作时需要把3，4，5一起往后移动一位腾出空间来放置100。 

又如要删除100了，那么需要把3，4，5移回来，即均往前移动一位。



平均而言，插入一个元素要移动当前List一半的元素。最坏的情况就是均要移动。

因此对于这种实现，Inset的时间复杂度是O(n)。



## 基于链表实现的List

**UPDATAE：以下之前有疑惑的地方解惑了。 就是基于链表的插入删除操作，我们不是告诉你插入或删除节点的下标位置，就比如插入到位置为100的地方。**

**是直接把Node给你，给你一个Node\* p，要你在这后面做插入或者删除操作。。**

找到要插入的位置抛开不谈，否则的话这里索引是要O(n)的······反倒Array按照下标索引是O(1)的。

仅仅谈插入过程，就是一个修改指针的过程，时间复杂度是O(1)的。比Array快。



给定待删除元素时，我们要先找到待删除元素的前一个位置。findPrev方法是O(n)的，而删除过程是很简单的。。

```c
prev->next = prev->next->next
```

就完事了，要delete掉的话就多一根指针就完事。

Anyway，删除操作我们按照O(n)计算。。。~~感觉怪诡异的，这里就把搜索的复杂度算进去了，额。~~



为了加速findPrev，可以构建双向链表，即Node这个struct多保存一根prev指针指向前面的节点。

这种方法弊端在于消耗了更多空间，在做插入删除操作时指针操作更加多，要更加仔细！





## 基于Array实现的Stack(一种先进后出的ADT):

### 优缺点：

1.实现简便

2.在构造stack对象时大小就得指定好

3.如果元素没放满空间就浪费了

4.放满后不能继续放入





## 基于链表实现的Stack

每个节点包含数据域和指针阈。

需要一个成员变量保持当前的栈顶位置，记为topPtr。栈最后一个元素的next指针域为NULL。

Push元素的时候，最新放入的元素要成为top。

Pop的时候就是把当前top弹出，新的top应该是未弹出前的top->next，别忘了delete操作。

拷贝构造中，深拷贝与shallow copy的区别。在代码中提到了，也写了shallow copy的代码，关掉注释运行一下，跟注释中提及的缺陷对照一下。【shallow copy会导致oldStack变空】





## 不同实现方式的Stack成员函数时间复杂度

成员函数有构造，是否满，是否空，清空，析构，放元素，弹出元素。

### 基于Array实现

都是O(1)时间复杂度

因为我们可以令topPtr为下标即可，Push之后就加一，Pop就减一，数组根据下标取元素也只要O(1)即可。

### 基于链表实现

清空和析构是O(n)的，因为其需要依靠循环遍历每一个Node，delete掉。





## 基于Array实现的queue(一种先进先出的ADT)

### 优缺点

1.实现简便

2.大小必须事先声明

3.同样存在浪费空间的问题

4.放满后不能继续放入





## 基于链表实现的queue

不同于栈，需要两个指针来标记队列的头和尾

原因很简单，我们放入元素时要放到队列尾，弹出元素是从头弹出的。

具体实现见code。





## 不同实现方式的Queue成员函数时间复杂度

成员函数有构造，是否满，是否空，清空，析构，元素入队，元素出队。

### 基于Array实现

都是O(1)时间复杂度，提一嘴出队入队可能会有的复杂情况。

因为我们可以令front和rear一开始都为下标0。入队时rear+1即可，出队则令front+1。

注意一种情况：

比如我们声明最大容量为5，一直入队元素，然后满了，那么rear index = 4， front index = 0。此时出队一个元素，front index = 1。空出来的位置是index = 0的位置，但再次入队一个元素 rear + 1 = 5。这样会数组越界，所以更加规范的写法应该是:

(rear + 1) % size 和 (front + 1) % size，取模，就能得到正确解了。   **---------size 为事先声明的最大容量。**

而判断是否为空，是否满的话，可以另外加一个成员变量capacity，入队则加一，出队则减一，根据capacity，0和size之间的关系来判断就很方便了。		**---------这一条思路和基于链表相同**

### 基于链表实现

清空和析构是O(n)的，因为其需要依靠循环遍历每一个Node，并delete。入队出队都仅仅是修改指针。





## Queue空间复杂度的一点比较

#### 1.假设一个队列，size为100，每个元素都是80Bytes的字符串

##### Array based：

假设标记一头一尾各需要2bytes，总共是(80 bytes x 101 slots) + (2 bytes x 2indexes) = 8084 bytes。

**Robert的解释是，用第101个位置来作为哨兵防止溢出。~~个人感觉可以但没必要，不如用一个short类型的capacity，也是2Byte，来和100比一比，就可以了·······~~ 但无论如何，这个其实是在于突出空间浪费的一个比较而已，所以无所谓。**



##### Linklist based：

仅需知道单个节点所占空间大小乘以最后节点数量即可。

假设指针是4Byte(在64bit的机器上是8Byte)，数据域就是那个80Byte的字符串，单个节点占84Byte。



因此当入队元素达到95+的时候两者所占空间相当，元素数量少时，Array Based的空间浪费太大。



#### 2.假设同样size为100的队列，但装入的是2Byte的short

##### Array based：

(2 bytes x 101 slots) + (2 bytes x 2indexes) = 206 bytes



##### Linklist based:

每个节点所占空间是 2 + 4 = 6Bytes



因此当入队元素34+左右两者空间差不多，元素少时空间有浪费，但相对于装80Byte元素而言浪费也比较少了。

**然而此时，当元素数量继续上升，假如装满，链表需要6 * 100 = 600Bytes，远大于206，究其原因是由那个4Byte的指针导致的。**